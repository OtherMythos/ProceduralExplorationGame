@piece( custom_ps_preExecution )
/*
	#define material materialArray[inPs.materialId]

	@property( diffuse_map )
	if(material.userValue[0].x == 1.0){
			float2 animUV = inPs.uv@value(uv_diffuse);
			animUV.x = animUV.x + sin(material.userValue[0].y * 2) * 0.001;
			animUV.y = animUV.y + cos(material.userValue[0].y * 2) * 0.001;

			inPs.uv0.xy = animUV;
	}
	@end
*/
@end

@piece( custom_passBuffer )
	float time;
	float playerPositionX;
	float playerPositionY;
	float playerPositionZ;

	float customX;
	float customY;
	float customZ;

	float fogR;
	float fogG;
	float fogB;

	float fogStart;
	float fogEnd;
	uint activeVoxelHighlightGroup;
@end

@piece( custom_ps_functions )

	@property( disableLightChanges )
		INLINE midf3 BRDF_Workaround( midf3 lightDir, midf3 lightDiffuse, midf3 lightSpecular, PixelData pixelData PASSBUF_ARG_DECL )
		{
			midf3 diffuse = lightDiffuse;
			diffuse.xyz = midf3_c(3.14159265, 3.14159265, 3.14159265);
			midf3 specular = lightSpecular;
			specular.xyz = midf3_c(3.14159265, 3.14159265, 3.14159265);

			return BRDF(lightDir, diffuse, specular, pixelData PASSBUF_ARG);
		}
	@end

@end

@piece( custom_ps_preLights )
	pixelData.diffuse.xyz *= inPs.ambientVal;
	@property(!invisibleTerrain && voxelTerrain)
		pixelData.diffuse.xyz *= (0.2 + inPs.voxelDiffuseVal * 0.8);

		if(passBuf.activeVoxelHighlightGroup != 0){
			if(passBuf.activeVoxelHighlightGroup != inPs.voxelHighlightGroup){
				pixelData.diffuse.xyz = float3(0.0);
			}
		}
	@end

	@property( disableLightChanges )
		#define BRDF BRDF_Workaround
	@end

	@property(oceanVertices)
		/*
		//Per-voxel glistening effect on 600x600 texture grid
		//Determine which voxel in the grid this fragment belongs to
		//Multiply texture coordinates by grid size and floor to get voxel indices
		int voxelX = int(floor(inPs.oceanTexCoord.x * 50.0));
		int voxelY = int(floor(inPs.oceanTexCoord.y * 50.0));

		//Create deterministic random seed per voxel
		float voxelHash = float(voxelX * 73 + voxelY * 179);
		//Use sine of hash to create base random offset (0-1)
		float baseOffset = fract(sin(voxelHash) * 43758.5453);

		//Animate smoothly using sine wave with slow time scaling
		//2Ï€ radians per cycle, divided by larger number for slower animation
		float animatedValue = sin(passBuf.time * 1.0 + baseOffset * 6.28319) * 0.5 + 0.5;

		//Convert to black and white, blend with texture at 0.5 strength
		float3 blackWhiteNoise = float3(animatedValue, animatedValue, 0);
		pixelData.diffuse.xyz = mix(pixelData.diffuse.xyz, blackWhiteNoise, 0.04);
		*/

		//Higher granularity sparkle layer (300x300 voxels)
		int sparkleX = int(floor(inPs.oceanTexCoord.x * 600.0));
		int sparkleY = int(floor(inPs.oceanTexCoord.y * 600.0));

		//Create deterministic random seed per sparkle voxel
		float sparkleHash = float(sparkleX * 73 + sparkleY * 179);
		float sparkleOffset = fract(sin(sparkleHash) * 43758.5453);

		//Each voxel has its own repeating sawtooth cycle based on time + offset
		//fract creates a repeating 0-1 sawtooth, multiply by 6.28 to get full radian cycle
		float sparklePhase = fract(passBuf.time * 0.00425 + sparkleOffset) * 6.28319;
		//Create smooth transition window: fade in from 0-0.039, peak at 0.039-0.1, fade out at 0.1-0.1375
		float fadeIn = smoothstep(0.0, 0.039, sparklePhase);
		float fadeOut = smoothstep(0.1375, 0.1, sparklePhase);
		float windowSmooth = fadeIn * fadeOut;
		//Within the window, animate from 0 to 1 and back
		float sparkleValue = windowSmooth * sin(sparklePhase * 2.495) * 0.5 + 0.5 * windowSmooth;

		//Blend sparkle layer on top (mix to keep mostly dark)
		pixelData.diffuse.xyz = mix(pixelData.diffuse.xyz, float3(sparkleValue, sparkleValue, 0), 0.05);
	@end
@end

@piece( custom_ps_posExecution )
	//For debug purposes
	//outPs_colour0.xyz = float3(inPs.diffuse.xyz);

	@property( !renderSceneDecorations )
		outPs_colour0.xyz *= (0.8 + inPs.ambientVal * 0.2);
	@end

	@property(windStreaks)
		float startDist = 20.0;
		float lengthDist = 150.0;
		if(inPs.windDistance >= startDist){
			float distanceDiff = (lengthDist - clamp(float(inPs.windDistance - startDist), 0.0, lengthDist)) / lengthDist;
			outPs_colour0.xyz = float3(distanceDiff);
		}else{
			outPs_colour0.xyz = float3(1, 1, 1);
		}
	@else
		@property( !disableFog )
			float3 fogColour = float3(passBuf.fogR, passBuf.fogG, passBuf.fogB);
			@property(invisibleTerrain)
				outPs_colour0.xyz *= inPs.fog;
				outPs_colour0.z = 1;
				outPs_colour0.w = inPs.fog;
			@else
				outPs_colour0.xyz = mix(fogColour, outPs_colour0.xyz, inPs.fog);
			@end
		@end

		@property(renderShadowVisibility)
			outPs_colour0.xyz = float3(1, 1, 1);
		@end
	@end

	@property( renderSceneDecorations )
		//float colVal = float(inPs.passDrawId % uint(100)) / 100.0;
		outPs_colour0.xyz = inPs.decorationColour;
		outPs_colour0.z = inPs.passDrawColour;
		@property(lineColourDangerous)
			outPs_colour0.w = 0.0; //Red line marker (dangerous)
		@else
			outPs_colour0.w = 1.0; //Default line marker (safe)
		@end
	@end

	@property(floorDecals)
		if(passBuf.customX > 0){
			float dist = distance(float2(passBuf.playerPositionX, passBuf.playerPositionZ), float2(inPs.worldPos.x, inPs.worldPos.z));
			float checkVal = 7;
			if(dist <= 20){
				if(dist <= checkVal){
					outPs_colour0.xyz = mix(outPs_colour0.xyz, float3(0, 0, 0), 0.3);
				}
				if(dist <= 20 && dist >= 20 - 0.5){
					outPs_colour0.xyz = mix(outPs_colour0.xyz, float3(1, 1, 1), 0.3);
				}
			}
		}
	@end
@end

@piece( custom_VStoPS )
	@property(floorDecals)
	float3 worldPos;
	@end
	@property( renderSceneDecorations )
		NO_INTERPOLATION_PREFIX float passDrawColour;
		float3 decorationColour;
	@else
		float fog;
		float ambientVal;
		@property(!invisibleTerrain && voxelTerrain)
			float voxelDiffuseVal;
			NO_INTERPOLATION_PREFIX uint voxelHighlightGroup;
		@end
	@end
	@property( windStreaks )
		float windDistance;
	@end
	@property(oceanVertices)
		float2 oceanTexCoord;
	@end
@end

@piece( custom_vs_posExecution )

	@property( !hlms_shadowcaster || !hlms_shadow_uses_depth_texture || alpha_test || exponential_shadow_maps && !renderSceneDecorations)
	@property( !disableFog && !renderSceneDecorations )
		float3 playerPosition = float3(passBuf.playerPositionX, passBuf.playerPositionY, passBuf.playerPositionZ);
		//float4 positionRelativeToCam = mul(worldPos, passBuf.viewProj);
		//float dist = length(positionRelativeToCam.xyz);
		float4 worldDistance = float4(playerPosition, 1.0) - worldPos;
		float dist = length(worldDistance.xyz);
		//float4 playerFinalPos = mul(float4(passBuf.playerPosition, 1.0), passBuf.viewProj);
		//float dist = distance(playerFinalPos.xyz, outVs_Position.xyz);
		//float dist = distance(passBuf.playerPosition, worldPos.xyz);

		//Expnential fog
		/*
		float density = 0.003;
		float gradient = 1.5;
		float visibility = exp(-pow(dist * density, gradient));
		*/

		/*
		//Explonential Squared
		float density = 0.002;
		float visibility = exp(-pow(dist * density, 2.0));
		*/

		//Sigmoid fog
		float fogStart = passBuf.fogStart;
		float fogEnd = passBuf.fogEnd;
		float visibility = smoothstep(fogEnd, fogStart, dist);

		visibility = clamp(visibility, 0.0, 1.0);
		outVs.fog = visibility;
	@end
		@property(floorDecals)
		outVs.worldPos = worldPos.xyz;
		@end
	@end

	@property( windStreaks )
		float4 positionRelativeToCam = mul(worldPos, passBuf.viewProj);
		float dist = length(positionRelativeToCam.xyz);
		outVs.windDistance = dist;
	@end

	@property( renderSceneDecorations )
		float colVal = float(finalDrawId % uint(100));
		float4 positionRelativeToCam = mul(worldPos, passBuf.viewProj);
		float dist = length(positionRelativeToCam.xyz);
		outVs.decorationColour = float3(1.0, dist, 0);
		outVs.passDrawColour = colVal;

		@property( treeVertices )
			//Workaround an issue found on the iPhone XR, where vertice animations were being applied causing some values to fail the depth buffer test.
			//Basically prioritise the line drawing algorithm slightly
			outVs_Position.z += 0.00001;
		@end
	@end

@end

@piece( custom_vs_preExecution )

	@property(packedVoxels)

		@property(!renderSceneDecorations)
		@insertpiece(voxelData)
		@end

		float4 inValues = inVs_vertex;
		@property( syntax == metal )
			uint original = as_type<uint>(inValues.x);
			uint originalSecond = as_type<uint>(inValues.y);
			uint originalThird = as_type<uint>(inValues.z);
		@else
			uint original = floatBitsToUint(inValues.x);
			uint originalSecond = floatBitsToUint(inValues.y);
			uint originalThird = floatBitsToUint(inValues.z);
		@end

		float3 normVal = float3(0, 0, 0);
		#undef inVs_normal
		#define inVs_normal normVal

		#undef inVs_vertex
		#define inVs_vertex inValues

		uint voxValue = originalSecond & uint(0xFF);
		uint voxFlags = (originalSecond >> 16) & uint(0xFF);

		@property(!renderSceneDecorations)
		const uint COLS_WIDTH = uint(16);
		const uint COLS_HEIGHT = uint(16);
		const float TILE_WIDTH = (1.0 / float(COLS_WIDTH)) / 2.0;
		const float TILE_HEIGHT = (1.0 / float(COLS_HEIGHT)) / 2.0;
		const float texCoordX = (float(voxValue % COLS_WIDTH) / COLS_WIDTH) + TILE_WIDTH;
		const float texCoordY = (float((uint(float(voxValue) / COLS_WIDTH))) / COLS_HEIGHT) + TILE_HEIGHT;
		const float2 testVal = float2(texCoordX, texCoordY);
		@else
		const float2 testVal = float2(0, 0);
		@end

		//float2 testVal = VOXEL_TEX_COORDS[voxValue];
		#undef inVs_uv0
		#define inVs_uv0 testVal

		int pos_x = int(original & uint(0x3FF));
		int pos_y = int((original >> 10) & uint(0x3FF));
		int pos_z = int((original >> 20) & uint(0x3FF));
		@property(offlineVoxels)
			pos_x -= 128;
			pos_y -= 128;
			pos_z -= 128;
		@end

		inValues.x = float(pos_x)-0.5;
		inValues.y = float(pos_y)-0.5;
		inValues.z = float(pos_z)-0.5;
		@property(voxelTerrain)
			inValues.z -= 4.0;
		@end

		uint norm = uint((originalSecond >> 29) & uint(0x7));
		uint ambient = uint((original >> 30) & uint(0x3));

		@property(treeVertices)
			@property( !hlms_shadowcaster || !hlms_shadow_uses_depth_texture || alpha_test || exponential_shadow_maps )
				uint voxel = ((originalSecond >> 8) & uint(0x3));
				float mod = float(voxel) / 3;
				inValues.y += sin(inValues.y*600 + passBuf.time) * 0.05 * mod;
				inValues.z += cos(inValues.z*600 + passBuf.time) * 0.10 * mod;
				inValues.x += sin(inValues.x*600 + passBuf.time) * 0.05 * mod;
			@end
		@end

		@property(!invisibleTerrain && voxelTerrain)
			//Hide voxels only if the terrain is not in the invisible state.
			uint test = voxFlags & uint(0x1);
			if(test > uint(0)){
				inValues.y = -100000.0;
			}
		@end

		@property(!renderSceneDecorations)
		normVal = FACES_NORMALS[norm];

		//If the renderable does not require pixel shading because it is a shadow caster for instance, these settings won't always be available.
		@property( !hlms_shadowcaster || !hlms_shadow_uses_depth_texture || alpha_test || exponential_shadow_maps )
			outVs.ambientVal = float(ambient)/3;
			@property(!invisibleTerrain && voxelTerrain)
				uint voxelDiffuse = uint((originalSecond >> 8) & uint(0x7));
				outVs.voxelDiffuseVal = float(voxelDiffuse)/7;
				outVs.voxelHighlightGroup = uint(originalThird & uint(0xFF));
			@end
		@end
		@end

	@else
		float4 inValues = inVs_vertex;
		#undef inVs_vertex
		#define inVs_vertex inValues

		@property( !hlms_shadowcaster || !hlms_shadow_uses_depth_texture || alpha_test || exponential_shadow_maps )
			@property(!renderSceneDecorations)
				outVs.ambientVal = 1.0;
			@end
		@end

		@property(oceanVertices)
			float animFlag = inVs_vertex.y;
			float animMod = 1.0 - animFlag;
			inVs_vertex.y = 0.0;
			inVs_vertex.y += cos(inVs_vertex.z * 3.14159265 * 200 + passBuf.time) * 0.25 * animMod;
			inVs_vertex.x += sin(inVs_vertex.x * 3.14159265 * 200 + passBuf.time) * 0.001 * animMod;
		@end

		@property(windStreaks)
			inVs_vertex.y += sin(inVs_vertex.z*10 + passBuf.time) * 0.75;
			inVs_vertex.x += sin(inVs_vertex.z*3 + passBuf.time * 4) * 2.75;
		@end

		@property(oceanVertices)
			//Pass texture coordinates for ocean glistening effect
			outVs.oceanTexCoord = inVs_uv0;
		@end
	@end


@end


@undefpiece(LightingHeader)

@piece( LightingHeader )
	//Everything's in Camera space
	@property( needs_view_dir )
		@property( !hlms_instanced_stereo )
			pixelData.viewDir	= midf3_c( normalize( -inPs.pos ) );
		@else
			if( gl_FragCoord.x > passBuf.rightEyePixelStartX )
				pixelData.viewDir = midf3_c( normalize( -inPs.pos + passBuf.leftToRightView.xyz ) );
			else
				pixelData.viewDir = midf3_c( normalize( -inPs.pos ) );
		@end
		pixelData.NdotV		= saturate( dot( pixelData.normal, pixelData.viewDir ) );
	@end

	@property( !ambient_fixed || vct_num_probes )
		midf3 finalColour = midf3_c(0, 0, 0);
	@else
		@property(removeAmbient)
			midf3 finalColour = pixelData.diffuse.xyz;
		@else
			midf3 finalColour = midf3_c( passBuf.ambientUpperHemi.xyz ) * pixelData.diffuse.xyz;
		@end
	@end

	@property( hlms_static_branch_shadow_map_lights || hlms_lights_point || hlms_lights_spot || hlms_lights_area_approx || hlms_lights_area_ltc )
		float3 lightDir;
		float fDistance;
		midf3 tmpColour;
		midf spotCosAngle;
	@end

	@property( hlms_static_branch_shadow_map_lights )
		const float2 shadowmap_uv_min[@value(hlms_num_shadow_map_lights)] =
			OGRE_ARRAY_START( float2 )
					hlms_shadowmap0_uv_min
					@foreach( hlms_num_shadow_map_lights, n, 1 )
					, hlms_shadowmap@n_uv_min@end
			OGRE_ARRAY_END;
		const float2 shadowmap_uv_max[@value(hlms_num_shadow_map_lights)] =
			OGRE_ARRAY_START( float2 )
				hlms_shadowmap0_uv_max
				@foreach( hlms_num_shadow_map_lights, n, 1 )
				, hlms_shadowmap@n_uv_max@end
			OGRE_ARRAY_END;
		const float2 shadowmap_uv_length[@value(hlms_num_shadow_map_lights)] =
			OGRE_ARRAY_START( float2 )
				hlms_shadowmap0_uv_length
				@foreach( hlms_num_shadow_map_lights, n, 1 )
				, hlms_shadowmap@n_uv_length@end
			OGRE_ARRAY_END;
	@end

	@property( needs_refl_dir )
		pixelData.reflDir = _h( 2.0 ) * dot( pixelData.viewDir, pixelData.normal ) * pixelData.normal -
							pixelData.viewDir;
	@end

	@insertpiece( DoAmbientHeader )
@end