@piece( custom_ps_preExecution )
	#define material materialArray[inPs.materialId]

	@property( diffuse_map )
	if(material.userValue[0].x == 1.0){
			float2 animUV = inPs.uv@value(uv_diffuse);
			animUV.x = animUV.x + sin(material.userValue[0].y * 2) * 0.001;
			animUV.y = animUV.y + cos(material.userValue[0].y * 2) * 0.001;

			inPs.uv0.xy = animUV;
	}
	@end
@end

@piece( custom_ps_preLights )

	if(material.userValue[0].x == 1.0){
		@property( diffuse_map )
		/*
		float2 animUV = inPs.uv@value(uv_diffuse);
		animUV.x = animUV.x + sin(material.userValue[0].y * 2) * 0.001;
		animUV.y = animUV.y + cos(material.userValue[0].y * 2) * 0.001;
		*/

		float PI = 3.14159265359;
		float2 uv = inPs.uv@value(uv_diffuse);
		float time = material.userValue[0].y * 10;
		float d1 = mod(uv.x + uv.y, PI*2);
		float d2 = mod((uv.x + uv.y + 0.25) * 1.3, PI*6);
		d1 = time * 0.07 + d1;
		d2 = time * 0.5 + d2;
		float2 dist = float2(
			sin(d1) * 0.15 + sin(d2) * 0.05,
			cos(d1) * 0.15 + cos(d2) * 0.05
		);
		float2 animUV = uv + dist * 0.01;


		inPs.uv0.xy = animUV;

/*
		float val = SampleDiffuse( textureMaps@value( diffuse_map_idx ),
										   samplerState@value(diffuse_map_sampler),
										   UV_DIFFUSE( animUV ),
										   texIndex_diffuseIdx ).x;
		if(val == 100.0/255.0){
			pixelData.diffuse.xyz = float3(0.125, 0.435, 0.788);
		}
		else if(val == 150.0/255.0){
			pixelData.diffuse.xyz = float3(0.7, 0.929, 0.925);
		}else{
			pixelData.diffuse.xyz = float3(0, 0, 0);
		}
		pixelData.diffuse.xyz = float3(0, 0, 0);
		*/

		@end
	}


	pixelData.diffuse.xyz *= inPs.diffuse;
@end

@piece( custom_ps_posExecution )
	//For debug purposes
	//outPs_colour0.xyz = float3(inPs.diffuse.xyz);
@end

@piece( custom_VStoPS )
	float3 diffuse;
@end
@piece( custom_vs_preExecution )
    const float3 FACES_NORMALS[6] = {
        float3(0, -1,  0),
        float3(0,  1,  0),
        float3(0,  0, -1),
        float3(0,  0,  1),
        float3(1,  0,  0),
        float3(-1, 0,  0),
    };

	float4 inValues = inVs_vertex;
	@property( syntax == metal )
		uint original = as_type<uint>(inValues.x);
		uint originalSecond = as_type<uint>(inValues.y);
	@else
		uint original = floatBitsToUint(inValues.x);
		uint originalSecond = floatBitsToUint(inValues.y);
	@end

	uint magicNumber = originalSecond & uint(0x1FFFFFFF);
	float3 normVal = float3(0, 0, 0);
	#undef inVs_normal
	#define inVs_normal normVal

	#undef inVs_vertex
	#define inVs_vertex inValues

	if(magicNumber == uint(0x15FBF7DB) || magicNumber == uint(0x15FBB7DB)){
		int offset = 0;
		if(magicNumber == uint(0x15FBB7DB)){
			offset = 128;
		}
		int pos_x = int(original & uint(0x3FF)) - offset;
		int pos_y = int((original >> 10) & uint(0x3FF)) - offset;
		int pos_z = int((original >> 20) & uint(0x3FF)) - offset;
		inValues.x = float(pos_x)-0.5;
		inValues.y = float(pos_y)-0.5;
		inValues.z = float(pos_z)-0.5;

		uint norm = uint((originalSecond >> 29) & uint(0x3));
		uint ambient = uint((original >> 30) & uint(0x3));

		normVal = FACES_NORMALS[norm];

		//If the renderable does not require pixel shading because it is a shadow caster for instance, these settings won't always be available.
		@property( !hlms_shadowcaster || !hlms_shadow_uses_depth_texture || alpha_test || exponential_shadow_maps )
			float ambientVal = float(ambient)/3;
			outVs.diffuse = float3(ambientVal, ambientVal, ambientVal);
		@end
	}else{
		@property( !hlms_shadowcaster || !hlms_shadow_uses_depth_texture || alpha_test || exponential_shadow_maps )
			outVs.diffuse = float3(1, 1, 1);
		@end
	}


@end
